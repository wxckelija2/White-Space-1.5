import { callPrivateFunction, isAuthenticated } from './auth-functions';
import * as FileSystem from 'expo-file-system';
import { FileProcessor, ProcessedFile } from './file-processor';

export type AITaskType = 'generate' | 'improve' | 'summarize' | 'expand' | 'rewrite';
export type AIProvider = 'huggingface' | 'openai' | 'anthropic' | 'gemini' | 'mock' | 'supabase-jobs' | 'supabase-echo' | 'auth-fallback' | 'supabase-edge-function';

export interface AIAttachment {
  uri: string;
  type: string;
  name: string;
  base64?: string;
  size: number;
}

export interface AITask {
  type: AITaskType;
  prompt: string;
  context?: string;
  conversationHistory?: Array<{ role: 'user' | 'assistant'; content: string }>;
  parameters?: Record<string, any>;
  attachments?: AIAttachment[];
  abortController?: AbortController;
}

export interface MessageAnalysis {
  intent: string;
  topic: string;
  category: 'academic' | 'business' | 'coding' | 'general' | 'homework';
  confidence: number;
  suggestions?: string[];
  relatedTopics?: string[];
}

export interface AIResponse {
  content: string;
  attachments?: AIAttachment[];
  metadata?: {
    model: string;
    tokens: number;
    processingTime: number;
    provider: AIProvider;
    jobId?: string;
    jobStatus?: string;
  };
}

class AIService {
  private provider: AIProvider = 'mock'; // Default to mock until Edge Function is deployed

  constructor() {
    // Initialize with environment variables
    const provider = process.env.EXPO_PUBLIC_AI_PROVIDER as AIProvider;
    console.log('üîç AI Constructor - EXPO_PUBLIC_AI_PROVIDER:', provider);
    if (provider && ['huggingface', 'openai', 'anthropic', 'gemini', 'mock'].includes(provider)) {
      this.provider = provider;
      console.log('‚úÖ AI Provider set to:', this.provider);
    } else {
      // Temporarily default to gemini for testing
      this.provider = 'gemini';
      console.log('‚ö†Ô∏è Defaulting to gemini provider');
    }
  }

  async generate(task: AITask): Promise<AIResponse> {
    const startTime = Date.now();
    console.log('üöÄ AI Generate called - Provider:', this.provider, 'Task:', task.type);

    try {
      // Check for cancellation before starting
      if (task.abortController?.signal.aborted) {
        throw new Error('Generation cancelled by user');
      }

      // Process attachments before generating
      const processedTask = await this.processAttachments(task);

      switch (this.provider) {
        case 'huggingface':
          console.log('üì° Calling HuggingFace API');
          return await this.generateWithHuggingFace(processedTask);
        case 'openai':
          console.log('üì° Calling OpenAI API');
          return await this.generateWithOpenAI(processedTask);
        case 'anthropic':
          console.log('üì° Calling Anthropic API');
          return await this.generateWithAnthropic(processedTask);
        case 'gemini':
          console.log('üì° Calling Gemini/Edge Function');
          return await this.generateWithGemini(processedTask);
        case 'mock':
        default:
          console.log('ü§ñ Using mock generation (fallback)');
          return await this.generateMock(processedTask);
      }
    } catch (error) {
      console.error('‚ùå AI generation failed:', error);
      console.error('Error details:', error instanceof Error ? error.message : String(error));

      // Check if it was cancelled
      if (task.abortController?.signal.aborted) {
        throw new Error('Generation cancelled by user');
      }

      // Fallback to mock generation
      console.log('üîÑ Falling back to mock generation');
      return await this.generateMock(task);
    } finally {
      const processingTime = Date.now() - startTime;
      console.log(`‚è±Ô∏è AI generation took ${processingTime}ms`);
    }
  }

  private async processAttachments(task: AITask): Promise<AITask> {
    if (!task.attachments || task.attachments.length === 0) {
      return task;
    }

    console.log('üìé Processing', task.attachments.length, 'attachments');

    const processedAttachments = await Promise.all(
      task.attachments.map(async (attachment) => {
        try {
          const processed = await FileProcessor.processFile(
            attachment.uri,
            attachment.type,
            attachment.name,
            attachment.size
          );

          return processed;
        } catch (error) {
          console.error('Failed to process attachment:', attachment.name, error);
          return attachment;
        }
      })
    );

    return {
      ...task,
      attachments: processedAttachments,
    };
  }

  private buildOpenAIMessageContent(task: AITask): any {
    const content = [];

    // Add text prompt
    if (task.prompt) {
      content.push({
        type: 'text',
        text: this.buildPrompt(task),
      });
    }

    // Add text content from documents
    if (task.attachments) {
      task.attachments.forEach(attachment => {
        if (attachment.textContent) {
          content.push({
            type: 'text',
            text: `Content from ${attachment.name}:\n${attachment.textContent}`,
          });
        } else if (attachment.type.startsWith('image/') && attachment.base64) {
          content.push({
            type: 'image_url',
            image_url: {
              url: `data:${attachment.type};base64,${attachment.base64}`,
            },
          });
        }
      });
    }

    return content.length > 0 ? content : this.buildPrompt(task);
  }

  private async generateWithHuggingFace(task: AITask): Promise<AIResponse> {
    const apiKey = process.env.EXPO_PUBLIC_HUGGINGFACE_API_KEY;
    if (!apiKey) {
      throw new Error('Hugging Face API key not configured');
    }

    // Determine model based on task type
    const model = this.getHuggingFaceModel(task.type);

    const response = await fetch(`https://api-inference.huggingface.co/models/${model}`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${apiKey}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        inputs: this.buildPrompt(task),
        parameters: {
          max_new_tokens: 500,
          temperature: 0.7,
          do_sample: true,
          ...task.parameters,
        },
      }),
    });

    if (!response.ok) {
      throw new Error(`Hugging Face API error: ${response.status}`);
    }

    const result = await response.json();

    return {
      content: this.parseHuggingFaceResponse(result),
      metadata: {
        model,
        tokens: result[0]?.generated_text?.length || 0,
        processingTime: 0,
        provider: 'huggingface',
      },
    };
  }

  private async generateWithOpenAI(task: AITask): Promise<AIResponse> {
    const apiKey = process.env.EXPO_PUBLIC_OPENAI_API_KEY;
    if (!apiKey) {
      throw new Error('OpenAI API key not configured');
    }

    const response = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${apiKey}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        model: task.attachments?.some(att => att.type.startsWith('image/')) ? 'gpt-4-vision-preview' : 'gpt-4',
        messages: [
          {
            role: 'system',
            content: this.getSystemPrompt(task.type),
          },
          {
            role: 'user',
            content: this.buildOpenAIMessageContent(task),
          },
        ],
        max_tokens: 1000,
        temperature: 0.7,
        ...task.parameters,
      }),
    });

    if (!response.ok) {
      throw new Error(`OpenAI API error: ${response.status}`);
    }

    const result = await response.json();

    return {
      content: result.choices[0]?.message?.content || '',
      metadata: {
        model: 'gpt-4',
        tokens: result.usage?.total_tokens || 0,
        processingTime: 0,
        provider: 'openai',
      },
    };
  }

  private async generateWithAnthropic(task: AITask): Promise<AIResponse> {
    const apiKey = process.env.EXPO_PUBLIC_ANTHROPIC_API_KEY;
    if (!apiKey) {
      throw new Error('Anthropic API key not configured');
    }

    const response = await fetch('https://api.anthropic.com/v1/messages', {
      method: 'POST',
      headers: {
        'x-api-key': apiKey,
        'anthropic-version': '2023-06-01',
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        model: 'claude-3-sonnet-20240229',
        max_tokens: 1000,
        system: this.getSystemPrompt(task.type),
        messages: [
          {
            role: 'user',
            content: this.buildPrompt(task),
          },
        ],
        temperature: 0.7,
        ...task.parameters,
      }),
    });

    if (!response.ok) {
      throw new Error(`Anthropic API error: ${response.status}`);
    }

    const result = await response.json();

    return {
      content: result.content[0]?.text || '',
      metadata: {
        model: 'claude-3-sonnet-20240229',
        tokens: result.usage?.input_tokens + result.usage?.output_tokens || 0,
        processingTime: 0,
        provider: 'anthropic',
      },
    };
  }

  // Basic typo correction for common creative writing terms
  private correctCommonTypos(prompt: string): string {
    let corrected = prompt;

    // Common word corrections for creative writing, coding, and business
    const corrections: { [key: string]: string } = {
      // Creative writing typos
      'betwwen': 'between',
      'histoerical': 'historical',
      'writting': 'writing',
      'charcter': 'character',
      'stroy': 'story',
      'poem': 'poem',
      'peotry': 'poetry',
      'dialouge': 'dialogue',
      'monolouge': 'monologue',
      'sceenplay': 'screenplay',
      'backstory': 'backstory',
      'wold-building': 'world-building',
      'creat': 'create',
      'improv': 'improve',
      'summariz': 'summarize',
      'expand': 'expand',
      'rewrit': 'rewrite',

      // Coding typos
      'functoin': 'function',
      'varible': 'variable',
      'declar': 'declare',
      'intializ': 'initialize',
      'paramter': 'parameter',
      'arguement': 'argument',
      'retun': 'return',
      'consol': 'console',
      'ajac': 'ajax',
      'asyc': 'async',
      'awai': 'await',
      'promis': 'promise',
      'callbac': 'callback',
      'databas': 'database',
      'querey': 'query',
      'tabl': 'table',
      'colum': 'column',
      'inde': 'index',
      'algorith': 'algorithm',
      'debuging': 'debugging',
      'optimiz': 'optimize',

      // Business typos
      'buisness': 'business',
      'monetiz': 'monetize',
      'strategi': 'strategy',
      'marketin': 'marketing',
      'entreprenuer': 'entrepreneur',
      'freelan': 'freelance',
      'ecommerc': 'ecommerce',
      'dropshiping': 'dropshipping',
      'affiliat': 'affiliate',
      'passiv': 'passive',
      'investmen': 'investment',
      'portfoli': 'portfolio',
      'roi': 'ROI',
      'scalabl': 'scalable'
    };

    // Apply corrections
    for (const [wrong, right] of Object.entries(corrections)) {
      const regex = new RegExp(`\\b${wrong}\\b`, 'gi');
      corrected = corrected.replace(regex, right);
    }

    // If the prompt changed, log the correction
    if (corrected !== prompt) {
      console.log('üîß Auto-corrected typos:', { original: prompt, corrected });
    }

    return corrected;
  }

  private generateCodeExample(language: string, task: string): string {
    return `// Code example for ${language}`;
  }

  private async generateWithGemini(task: AITask): Promise<AIResponse> {
    console.log('üîó Calling Supabase Edge Function with task:', task);
    try {
      // Check if user is authenticated
      const authenticated = await isAuthenticated();
      if (!authenticated) {
        console.log('üîê User not authenticated, using mock mode');
        return await this.generateMock(task);
      }

      // Apply basic typo corrections for common creative writing terms
      let correctedPrompt = this.correctCommonTypos(task.prompt);

      // Call the private function with automatic token handling
      const data = await callPrivateFunction(correctedPrompt);

      console.log('‚úÖ Edge Function success - response:', data);

      // Handle successful response - support multiple response formats
      let content: string | null = null;
      let metadata: any = {};

      if (data?.content) {
        // Standard format: {content: "...", model: "...", tokens: ...}
        content = data.content;
        metadata = {
          model: data.model || 'gemini-flash-latest',
          tokens: data.tokens || data.content.length,
          processingTime: data.processingTime || 0,
          provider: 'supabase-edge-function',
        };
      } else if (data?.message) {
        // Simple response format: {message: "..."}
        content = data.message;
        metadata = {
          model: 'direct-response',
          tokens: data.message.length,
          processingTime: 0,
          provider: 'supabase-edge-function',
        };
      } else if (typeof data === 'string') {
        // Raw string response
        content = data;
        metadata = {
          model: 'unknown',
          tokens: data.length,
          processingTime: 0,
          provider: 'supabase-edge-function',
        };
      }

      console.log('‚úÖ Content extracted:', content ? content.substring(0, 50) + '...' : 'none');

      if (content) {
        return {
          content,
          metadata,
        };
      }

      // If we get here, something unexpected happened
      console.log('‚ö†Ô∏è Could not extract content from Edge Function response:', data);
      console.log('üîÑ Falling back to mock response');
      return await this.generateMock(task);
    } catch (err: any) {
      console.error('üí• generateWithGemini threw error:', err);

      // For any error, fall back to mock for better UX
      console.log('üîÑ Falling back to mock generation due to Edge Function error');
      return await this.generateMock(task);
    }
  }

  private async generateMock(task: AITask): Promise<AIResponse> {
    // Simulate API delay with cancellation support
    await new Promise((resolve, reject) => {
      const timeout = setTimeout(resolve, 1500 + Math.random() * 1000);

      // Listen for abort signal
      if (task.abortController?.signal) {
        task.abortController.signal.addEventListener('abort', () => {
          clearTimeout(timeout);
          reject(new Error('Generation cancelled by user'));
        });
      }
    });

    let contextAwareResponse = false;
    const analysis: MessageAnalysis = {
      intent: '',
      topic: 'general',
      category: 'general',
      confidence: 0.5
    };

    const prompt = task.prompt.toLowerCase();

    // Check if this is a follow-up question
    const previousAssistantMessages = task.conversationHistory
      .filter(m => m.role === 'assistant')
      .slice(-2);

    if (previousAssistantMessages.length > 0) {
      contextAwareResponse = true;
      // Look for follow-up indicators
      const isFollowUp = prompt.includes('more') || prompt.includes('also') ||
                        prompt.includes('what about') || prompt.includes('can you') ||
                        prompt.includes('how about') || prompt.startsWith('what') ||
                        prompt.startsWith('how') || prompt.startsWith('why');

      if (isFollowUp) {
        // Reference previous conversation
        const lastAssistantMessage = previousAssistantMessages[previousAssistantMessages.length - 1];
        console.log('üìù Detected follow-up question, referencing previous context');
        // Store context for use in response generation
        analysis.relatedTopics = analysis.relatedTopics || [];
        analysis.relatedTopics.push(...(lastAssistantMessage.content.substring(0, 100).split(' ').slice(0, 3)));
      }
    }

    // Smart mock responses based on user input
    let response: string;

    if (prompt === 'hey' || prompt === 'hi' || prompt === 'hello') {
      response = "Hey";
    } else if (prompt === 'what can you do') {
      response = "I help with math, homework, coding, business";
    } else if (prompt.includes('business') || prompt.includes('startup') || prompt.includes('company')) {
      response = "What's your business idea?";
    } else if (prompt.includes('monetize') || prompt.includes('make money') || prompt.includes('income')) {
      response = "What skills do you have?";
    } else if (prompt.includes('marketing') || prompt.includes('strategy') || prompt.includes('campaign') || prompt.includes('social media') || prompt.includes('advertising')) {
      response = "What's your marketing goal?";
    } else if (prompt.includes('passive income') || prompt.includes('automation') || prompt.includes('scale')) {
      response = "What content do you have?";
    } else if (prompt.includes('freelance') || prompt.includes('consulting') || prompt.includes('service business')) {
      response = "What service do you provide?";
    } else if (prompt.includes('homework') || prompt.includes('assignment') || prompt.includes('essay') || prompt.includes('write a')) {
      response = "What's the assignment?";
    } else if (prompt.includes('supabase') && !prompt.includes('code')) {
      response = "What Supabase feature?";
    } else if (prompt.includes('math') || prompt.includes('algebra') || prompt.includes('calculus') || prompt.includes('geometry') || prompt.includes('solve') || prompt.includes('equation') || /\d+\s*[+\-*/\^=]/.test(task.prompt)) {
      const mathPrompt = task.prompt.toLowerCase().trim();
      if (mathPrompt === '4x+8') {
        response = "Solve for what?";
      } else {
        response = "Share the equation";
      }
    } else if (prompt.includes('science') || prompt.includes('physics') || prompt.includes('chemistry') || prompt.includes('biology')) {
      response = "What's the science question?";
    } else if (prompt.includes('code') || prompt.includes('programming') || prompt.includes('function') || prompt.includes('debug') ||
               prompt.includes('javascript') || prompt.includes('python') || prompt.includes('java') ||
               prompt.includes('c++') || prompt.includes('php') || prompt.includes('html') || prompt.includes('css') ||
               prompt.includes('supabase')) {
      response = "What code do you need?";
    } else if (prompt.length < 10) {
      // Very short prompts - ask for clarification
      response = "What do you need help with? Be specific!";
    } else {
      response = "What do you need?";
    }

    // Handle attachments in mock response
    if (task.attachments && task.attachments.length > 0) {
      const attachmentTypes = task.attachments.map(att => att.type.split('/')[0]).filter((type, index, arr) => arr.indexOf(type) === index);
      const hasImages = attachmentTypes.includes('image');
      const hasDocuments = attachmentTypes.includes('application') || attachmentTypes.includes('text');

      if (hasImages && hasDocuments) {
        response += "\n\nI can see you've attached both images and documents. I'll analyze the images and extract information from the documents to help you.";
      } else if (hasImages) {
        response += "\n\nI can see you've attached images. I'll analyze them and provide relevant insights.";
      } else if (hasDocuments) {
        response += "\n\nI can see you've attached documents. I'll process them and provide relevant information.";
      }
    }

    return {
      content: response,
      metadata: {
        model: 'mock-gpt-enhanced',
        tokens: response.length,
        processingTime: 2000,
        provider: 'mock',
      },
    };
  }

  private getHuggingFaceModel(taskType: AITaskType): string {
    // Use appropriate models based on task type
    const models = {
      generate: 'microsoft/DialoGPT-medium',
      improve: 'facebook/bart-large-cnn',
      summarize: 'facebook/bart-large-cnn',
      expand: 'gpt2',
      rewrite: 'facebook/bart-large-cnn',
    };

    return models[taskType] || models.generate;
  }

  private parseHuggingFaceResponse(result: any): string {
    if (Array.isArray(result) && result[0]?.generated_text) {
      return result[0].generated_text;
    }
    return 'Generated content not available';
  }

  private parseGeminiResponse(result: any): string {
    try {
      if (result.candidates && result.candidates[0]?.content?.parts?.[0]?.text) {
        return result.candidates[0].content.parts[0].text;
      }
      return 'Generated content not available';
    } catch (error) {
      console.error('Error parsing Gemini response:', error);
      return 'Generated content not available';
    }
  }

  private buildGeminiPrompt(task: AITask): string {
    let prompt = '';

    // Add system instruction based on task type
    switch (task.type) {
      case 'generate':
        prompt = 'You are a creative writing assistant. Generate high-quality, engaging content based on the user\'s request.\n\n';
        break;
      case 'improve':
        prompt = 'You are an editor. Improve the provided content by enhancing clarity, structure, and impact while preserving the original intent.\n\n';
        break;
      case 'summarize':
        prompt = 'You are a summarization expert. Create concise, comprehensive summaries that capture the key points and main ideas.\n\n';
        break;
      case 'expand':
        prompt = 'You are a content expansion specialist. Add relevant details, examples, and context to make the content more comprehensive.\n\n';
        break;
      case 'rewrite':
        prompt = 'You are a professional writer. Rewrite the content to improve flow, clarity, and engagement.\n\n';
        break;
    }

    // Add context if provided
    if (task.context) {
      prompt += `Context: ${task.context}\n\n`;
    }

    // Add the main prompt
    prompt += `Request: ${task.prompt}`;

    return prompt;
  }

  private getSystemPrompt(taskType: AITaskType): string {
    const prompts = {
      generate: 'You are a comprehensive AI assistant that helps with both business/entrepreneurship topics AND academic subjects like homework, math, science, writing, coding, and more. Provide clear, helpful, and accurate responses whether the user needs business advice or help with schoolwork.',
      improve: 'You are an expert editor and consultant. Improve content, business plans, academic essays, or any written work by enhancing clarity, structure, and impact while preserving the original intent and meaning.',
      summarize: 'You are an expert at creating concise summaries. Summarize business documents, academic papers, articles, or any content, capturing key points, main ideas, and essential information clearly.',
      expand: 'You are a content development specialist. Add relevant details, examples, context, and explanations to expand business plans, academic essays, research, or any content to make it more comprehensive and complete.',
      rewrite: 'You are a professional writer and editor. Rewrite any content - business plans, academic papers, marketing copy, or general writing - to improve flow, clarity, engagement, and effectiveness.',
    };

    return prompts[taskType] || prompts.generate;
  }

  private buildPrompt(task: AITask): string {
    let prompt = task.prompt;

    if (task.context) {
      prompt = `Context: ${task.context}\n\nRequest: ${task.prompt}`;
    }

    // Add task-specific instructions
    switch (task.type) {
      case 'improve':
        prompt = `Please improve this content:\n\n${task.prompt}`;
        break;
      case 'summarize':
        prompt = `Please summarize this content:\n\n${task.prompt}`;
        break;
      case 'expand':
        prompt = `Please expand on this content with more details and examples:\n\n${task.prompt}`;
        break;
      case 'rewrite':
        prompt = `Please rewrite this content:\n\n${task.prompt}`;
        break;
    }

    return prompt;
  }

  // Utility method to check if AI service is available
  async isAvailable(): Promise<boolean> {
    try {
      if (this.provider === 'mock') return true;

      // Quick test call to check API availability
      const testTask: AITask = {
        type: 'generate',
        prompt: 'Hello',
      };

      await this.generate(testTask);
      return true;
    } catch {
      return false;
    }
  }

  // Method to get available providers based on configured API keys
  getAvailableProviders(): AIProvider[] {
    const providers: AIProvider[] = ['mock'];

    if (process.env.EXPO_PUBLIC_HUGGINGFACE_API_KEY) {
      providers.push('huggingface');
    }
    if (process.env.EXPO_PUBLIC_OPENAI_API_KEY) {
      providers.push('openai');
    }
    if (process.env.EXPO_PUBLIC_ANTHROPIC_API_KEY) {
      providers.push('anthropic');
    }
    if (process.env.EXPO_PUBLIC_GEMINI_API_KEY) {
      providers.push('gemini');
    }

    return providers;
  }

  // Method to switch providers
  setProvider(provider: AIProvider) {
    if (this.getAvailableProviders().includes(provider)) {
      this.provider = provider;
    } else {
      throw new Error(`Provider ${provider} is not available`);
    }
  }

  // Build conversation context from history
  private buildConversationContext(task: AITask): string {
    if (!task.conversationHistory || task.conversationHistory.length === 0) {
      return '';
    }

    // Take last 6 messages for context (3 exchanges)
    const recentHistory = task.conversationHistory.slice(-6);
    const contextParts: string[] = [];

    contextParts.push('Previous conversation context:');
    recentHistory.forEach((msg, idx) => {
      const role = msg.role === 'user' ? 'User' : 'Assistant';
      contextParts.push(`${role}: ${msg.content}`);
    });

    return contextParts.join('\n');
  }

  // Generate code examples for different languages
  private generateCodeExample(language: string, task: string): string {
    const lowerMessage = message.toLowerCase();

    // Determine category
    let category: MessageAnalysis['category'] = 'general';
    let topic = '';
    let intent = 'question';

    if (lowerMessage.includes('homework') || lowerMessage.includes('assignment') || lowerMessage.includes('essay')) {
      category = 'homework';
      topic = 'academic assignment';
      intent = 'homework_help';
    } else if (lowerMessage.includes('math') || lowerMessage.includes('solve') || lowerMessage.includes('equation') || /\d+\s*[+\-*/\^=]/.test(message)) {
      category = 'academic';
      topic = 'mathematics';
      intent = 'math_problem';
    } else if (lowerMessage.includes('code') || lowerMessage.includes('programming') || lowerMessage.includes('javascript') || lowerMessage.includes('python') || lowerMessage.includes('function') || lowerMessage.includes('class')) {
      category = 'coding';
      topic = 'programming';
      intent = 'coding_help';
    } else if (lowerMessage.includes('business') || lowerMessage.includes('startup') || lowerMessage.includes('company') || lowerMessage.includes('market') || lowerMessage.includes('monetize') || lowerMessage.includes('revenue')) {
      category = 'business';
      topic = 'business strategy';
      intent = 'business_advice';
    }

    return {
      intent,
      topic,
      category,
      confidence: 0.8,
      suggestions: [],
      relatedTopics: []
    };
  }
}

// Export singleton instance
export const aiService = new AIService();
    
    // Determine category
    let category: MessageAnalysis['category'] = 'general';
    let topic = '';
    let intent = 'question';
    
    if (lowerMessage.includes('homework') || lowerMessage.includes('assignment') || lowerMessage.includes('essay')) {
      category = 'homework';
      topic = 'academic assignment';
      intent = 'homework_help';
    } else if (lowerMessage.includes('math') || lowerMessage.includes('solve') || lowerMessage.includes('equation') || /\d+\s*[+\-*/\^=]/.test(message)) {
      category = 'academic';
      topic = 'mathematics';
      intent = 'math_problem';
    } else if (lowerMessage.includes('business') || lowerMessage.includes('startup') || lowerMessage.includes('revenue') || lowerMessage.includes('monetize')) {
      category = 'business';
      topic = 'business strategy';
      intent = 'business_advice';
    } else if (lowerMessage.includes('code') || lowerMessage.includes('programming') || lowerMessage.includes('function') || lowerMessage.includes('debug')) {
      category = 'coding';
      topic = 'programming';
      intent = 'coding_help';
    } else if (lowerMessage.includes('explain') || lowerMessage.includes('what is') || lowerMessage.includes('how does')) {
      category = 'academic';
      topic = 'explanation';
      intent = 'explanation_request';
    } else if (lowerMessage.includes('write') || lowerMessage.includes('create') || lowerMessage.includes('draft')) {
      category = 'academic';
      topic = 'writing';
      intent = 'writing_assistance';
    }
    
    // Extract suggestions from conversation history
    const suggestions: string[] = [];
    const relatedTopics: string[] = [];
    
    if (conversationHistory && conversationHistory.length > 0) {
      // Look for related topics in previous messages
      const lastAssistantMessage = [...conversationHistory].reverse().find(m => m.role === 'assistant');
      if (lastAssistantMessage) {
        // Extract potential topics from previous response
        const keywords = lastAssistantMessage.content.toLowerCase().match(/\b\w{5,}\b/g) || [];
        relatedTopics.push(...keywords.slice(0, 3));
      }
    }
    
    // Generate suggestions based on category
    if (category === 'homework') {
      suggestions.push('I can help structure your essay', 'Need help with research?', 'Want me to check your citations?');
    } else if (category === 'academic' && topic === 'mathematics') {
      suggestions.push('I can solve step-by-step', 'Want to see the formula?', 'Need practice problems?');
    } else if (category === 'business') {
      suggestions.push('I can create a business plan', 'Want marketing strategies?', 'Need financial projections?');
    } else if (category === 'coding') {
      suggestions.push('I can debug your code', 'Want best practices?', 'Need code examples?');
    }
    
    // Calculate confidence based on keyword matches
    const keywordMatches: Record<string, string[]> = {
      academic: ['homework', 'math', 'science', 'essay', 'assignment', 'test', 'study'],
      business: ['business', 'startup', 'revenue', 'marketing', 'profit', 'monetize'],
      coding: ['code', 'programming', 'function', 'debug', 'javascript', 'python', 'error'],
      homework: ['homework', 'assignment', 'essay', 'project', 'due'],
      general: ['help', 'explain', 'what', 'how', 'why', 'tell'],
    };
    
    const categoryKeywords = keywordMatches[category] || [];
    const matches = categoryKeywords.filter((kw: string) => lowerMessage.includes(kw)).length;
    const confidence = categoryKeywords.length > 0 
      ? Math.min(0.9, 0.5 + (matches / categoryKeywords.length) * 0.4)
      : 0.5;
    
    return {
      intent,
      topic,
      category,
      confidence,
      suggestions: suggestions.length > 0 ? suggestions : undefined,
      relatedTopics: relatedTopics.length > 0 ? relatedTopics : undefined,
    };
  }
}

// Export singleton instance
export const aiService = new AIService();
    curr = next;
  }
  return curr;
}

// Recursive version
function fibonacciRecursive(n) {
  if (n <= 1) return n;
  return fibonacciRecursive(n - 1) + fibonacciRecursive(n - 2);
}

// Usage
console.log(fibonacci(10)); // 55
console.log(fibonacciRecursive(10)); // 55`;
      } else if (lang === 'python') {
        return `# Fibonacci Algorithm in Python
def fibonacci(n):
    if n <= 1:
        return n

    prev, curr = 0, 1
    for _ in range(2, n + 1):
        prev, curr = curr, prev + curr
    return curr

# Recursive version
def fibonacci_recursive(n):
    if n <= 1:
        return n
    return fibonacci_recursive(n - 1) + fibonacci_recursive(n - 2)

# Usage
print(fibonacci(10))  # 55
print(fibonacci_recursive(10))  # 55`;
      }
    }

    if (lang === 'javascript' || lang === 'js') {
      if (taskLower.includes('function') || taskLower.includes('hello')) {
        return `// JavaScript Function Example
function greetUser(name) {
  return \`Hello, \${name}! Welcome to JavaScript!\`;
}

// Usage
console.log(greetUser("World")); // Output: Hello, World! Welcome to JavaScript!`;
      } else if (taskLower.includes('array') || taskLower.includes('loop')) {
        return `// JavaScript Array Operations & Algorithms
const numbers = [1, 2, 3, 4, 5];

// Map - transform each element
const doubled = numbers.map(num => num * 2);
console.log(doubled); // [2, 4, 6, 8, 10]

// Filter - get even numbers
const evens = numbers.filter(num => num % 2 === 0);
console.log(evens); // [2, 4]

// Reduce - sum all numbers
const sum = numbers.reduce((total, num) => total + num, 0);
console.log(sum); // 15

// Bubble Sort Algorithm
function bubbleSort(arr) {
  const n = arr.length;
  for (let i = 0; i < n - 1; i++) {
    for (let j = 0; j < n - i - 1; j++) {
      if (arr[j] > arr[j + 1]) {
        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
      }
    }
  }
  return arr;
}

const unsorted = [64, 34, 25, 12, 22, 11, 90];
console.log(bubbleSort([...unsorted])); // [11, 12, 22, 25, 34, 64, 90]`;
      } else if (taskLower.includes('sort') || taskLower.includes('algorithm')) {
        return `// JavaScript Sorting Algorithms

// Quick Sort
function quickSort(arr) {
  if (arr.length <= 1) return arr;

  const pivot = arr[arr.length - 1];
  const left = arr.filter(x => x < pivot);
  const right = arr.filter(x => x > pivot);
  const equal = arr.filter(x => x === pivot);

  return [...quickSort(left), ...equal, ...quickSort(right)];
}

// Merge Sort
function mergeSort(arr) {
  if (arr.length <= 1) return arr;

  const mid = Math.floor(arr.length / 2);
  const left = mergeSort(arr.slice(0, mid));
  const right = mergeSort(arr.slice(mid));

  return merge(left, right);
}

function merge(left, right) {
  const result = [];
  let i = 0, j = 0;

  while (i < left.length && j < right.length) {
    if (left[i] < right[j]) {
      result.push(left[i]);
      i++;
    } else {
      result.push(right[j]);
      j++;
    }
  }

  return result.concat(left.slice(i)).concat(right.slice(j));
}

// Usage
const arr = [64, 34, 25, 12, 22, 11, 90];
console.log('Quick Sort:', quickSort([...arr]));
console.log('Merge Sort:', mergeSort([...arr]));`;
      }
    } else if (lang === 'python') {
      if (taskLower.includes('function') || taskLower.includes('hello')) {
        return `# Python Function Example
def greet_user(name):
    return f"Hello, {name}! Welcome to Python!"

# Usage
print(greet_user("World"))  # Output: Hello, World! Welcome to Python!`;
      } else if (taskLower.includes('list') || taskLower.includes('loop')) {
        return `# Python List Operations & Algorithms
numbers = [1, 2, 3, 4, 5]

# List comprehension - double each number
doubled = [num * 2 for num in numbers]
print(doubled)  # [2, 4, 6, 8, 10]

# Filter even numbers
evens = [num for num in numbers if num % 2 == 0]
print(evens)  # [2, 4]

# Sum all numbers
total = sum(numbers)
print(total)  # 15

# Bubble Sort Algorithm
def bubble_sort(arr):
    n = len(arr)
    for i in range(n - 1):
        for j in range(n - i - 1):
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
    return arr

unsorted = [64, 34, 25, 12, 22, 11, 90]
print(bubble_sort(unsorted[:]))  # [11, 12, 22, 25, 34, 64, 90]`;
      } else if (taskLower.includes('sort') || taskLower.includes('algorithm')) {
        return `# Python Sorting Algorithms

# Quick Sort
def quick_sort(arr):
    if len(arr) <= 1:
        return arr

    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]

    return quick_sort(left) + middle + quick_sort(right)

# Merge Sort
def merge_sort(arr):
    if len(arr) <= 1:
        return arr

    mid = len(arr) // 2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])

    return merge(left, right)

def merge(left, right):
    result = []
    i = j = 0

    while i < len(left) and j < len(right):
        if left[i] < right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1

    result.extend(left[i:])
    result.extend(right[j:])
    return result

# Usage
arr = [64, 34, 25, 12, 22, 11, 90]
print('Quick Sort:', quick_sort(arr[:]))
print('Merge Sort:', merge_sort(arr[:]))`;
      }
    } else if (lang === 'java') {
      return `// Java Hello World
public class HelloWorld {
    public static void main(String[] args) {
        System.out.println("Hello, World! Welcome to Java!");
    }
}`;
    } else if (lang === 'cpp' || lang === 'c++') {
      return `// C++ Hello World
#include <iostream>

int main() {
    std::cout << "Hello, World! Welcome to C++!" << std::endl;
    return 0;
}`;
    } else if (lang === 'csharp' || lang === 'c#') {
      return `// C# Hello World
using System;

class Program {
    static void Main(string[] args) {
        Console.WriteLine("Hello, World! Welcome to C#!");
    }
}`;
    } else if (lang === 'php') {
      return `<?php
// PHP Hello World
echo "Hello, World! Welcome to PHP!";
?>`;
    } else if (lang === 'ruby') {
      return `# Ruby Hello World
puts "Hello, World! Welcome to Ruby!"`;
    } else if (lang === 'go') {
      return `// Go Hello World
package main

import "fmt"

func main() {
    fmt.Println("Hello, World! Welcome to Go!")
}`;
    } else if (lang === 'rust') {
      return `// Rust Hello World
fn main() {
    println!("Hello, World! Welcome to Rust!");
}`;
    } else if (lang === 'swift') {
      return `// Swift Hello World
print("Hello, World! Welcome to Swift!")`;
    } else if (lang === 'kotlin') {
      return `// Kotlin Hello World
fun main() {
    println("Hello, World! Welcome to Kotlin!")
}`;
    } else if (lang === 'typescript') {
      return `// TypeScript Hello World
function greetUser(name: string): string {
    return \`Hello, \${name}! Welcome to TypeScript!\`;
}

console.log(greetUser("World")); // Output: Hello, World! Welcome to TypeScript!`;
    } else if (lang === 'html' || lang === 'web') {
      return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hello World</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
            margin: 50px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        h1 {
            color: #fff;
            font-size: 2.5em;
            margin-bottom: 20px;
        }
        .container {
            max-width: 600px;
            margin: 0 auto;
            padding: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Hello, World! Welcome to Web Development!</h1>
        <p>This is a beautiful HTML page with modern CSS styling.</p>
        <p>Built with responsive design and gradient backgrounds!</p>
    </div>
</body>
</html>`;
    } else if (lang === 'react') {
      return `import React, { useState } from 'react';

// React Functional Component Example
function HelloWorld() {
  const [name, setName] = useState('World');

  return (
    <div style={{
      textAlign: 'center',
      padding: '50px',
      fontFamily: 'Arial, sans-serif'
    }}>
      <h1>Hello, {name}! Welcome to React!</h1>
      <input
        type="text"
        value={name}
        onChange={(e) => setName(e.target.value)}
        placeholder="Enter your name"
        style={{
          padding: '10px',
          fontSize: '16px',
          marginTop: '20px',
          borderRadius: '5px',
          border: '1px solid #ccc'
        }}
      />
      <p>This is a simple React component with state!</p>
    </div>
  );
}

export default HelloWorld;`;
    } else if (lang === 'css') {
      return `/* Modern CSS Example */
.container {
  max-width: 1200px;
  margin: 0 auto;
  padding: 20px;
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
  gap: 20px;
}

.card {
  background: white;
  border-radius: 10px;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
  padding: 20px;
  transition: transform 0.3s ease, box-shadow 0.3s ease;
}

.card:hover {
  transform: translateY(-5px);
  box-shadow: 0 8px 12px rgba(0, 0, 0, 0.15);
}

.button {
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: white;
  border: none;
  padding: 12px 24px;
  border-radius: 25px;
  cursor: pointer;
  font-size: 16px;
  transition: transform 0.2s ease;
}

.button:hover {
  transform: scale(1.05);
}

@media (max-width: 768px) {
  .container {
    grid-template-columns: 1fr;
  }
}`;
    } else if (lang === 'sql') {
      return `-- SQL Examples
-- Create a users table
CREATE TABLE users (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL,
    email TEXT UNIQUE,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- Insert data
INSERT INTO users (name, email) VALUES
('John Doe', 'john@example.com'),
('Jane Smith', 'jane@example.com');

-- Query data
SELECT * FROM users WHERE name LIKE 'J%';

-- Update data
UPDATE users SET email = 'john.doe@example.com' WHERE id = 1;

-- Delete data
DELETE FROM users WHERE id = 2;`;
    } else if (lang === 'supabase') {
      if (taskLower.includes('edge') || taskLower.includes('function')) {
        return `import { serve } from 'https://deno.land/std@0.168.0/http/server.ts'
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
}

serve(async (req) => {
  // Handle CORS
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders })
  }

  try {
    const { prompt } = await req.json()

    // Create Supabase client
    const supabaseClient = createClient(
      Deno.env.get('SUPABASE_URL') ?? '',
      Deno.env.get('SUPABASE_ANON_KEY') ?? ''
    )

    // Your function logic here
    const data = { message: \`Processed: \${prompt}\` }

    return new Response(
      JSON.stringify(data),
      {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 200,
      },
    )
  } catch (error) {
    return new Response(
      JSON.stringify({ error: error.message }),
      {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 400,
      },
    )
  }
})`;
      } else if (taskLower.includes('auth') || taskLower.includes('login')) {
        return `import { createClient } from '@supabase/supabase-js'

const supabaseUrl = process.env.EXPO_PUBLIC_SUPABASE_URL!
const supabaseAnonKey = process.env.EXPO_PUBLIC_SUPABASE_ANON_KEY!

const supabase = createClient(supabaseUrl, supabaseAnonKey)

// Sign up function
export async function signUp(email: string, password: string) {
  const { data, error } = await supabase.auth.signUp({
    email,
    password,
  })

  if (error) throw error
  return data
}

// Sign in function
export async function signIn(email: string, password: string) {
  const { data, error } = await supabase.auth.signInWithPassword({
    email,
    password,
  })

  if (error) throw error
  return data
}

// Sign out function
export async function signOut() {
  const { error } = await supabase.auth.signOut()
  if (error) throw error
}

// Get current user
export async function getCurrentUser() {
  const { data: { user } } = await supabase.auth.getUser()
  return user
}

// Auth state listener
export function onAuthStateChange(callback: (user: any) => void) {
  return supabase.auth.onAuthStateChange((_event, session) => {
    callback(session?.user ?? null)
  })
}`;
      } else if (taskLower.includes('database') || taskLower.includes('crud')) {
        return `import { createClient } from '@supabase/supabase-js'

const supabase = createClient(
  process.env.EXPO_PUBLIC_SUPABASE_URL!,
  process.env.EXPO_PUBLIC_SUPABASE_ANON_KEY!
)

// Types
interface User {
  id: string
  name: string
  email: string
  created_at: string
}

// CREATE - Insert new user
export async function createUser(userData: Omit<User, 'id' | 'created_at'>) {
  const { data, error } = await supabase
    .from('users')
    .insert([userData])
    .select()

  if (error) throw error
  return data[0]
}

// READ - Get all users
export async function getUsers() {
  const { data, error } = await supabase
    .from('users')
    .select('*')
    .order('created_at', { ascending: false })

  if (error) throw error
  return data
}

// READ - Get user by ID
export async function getUserById(id: string) {
  const { data, error } = await supabase
    .from('users')
    .select('*')
    .eq('id', id)
    .single()

  if (error) throw error
  return data
}

// UPDATE - Update user
export async function updateUser(id: string, updates: Partial<User>) {
  const { data, error } = await supabase
    .from('users')
    .update(updates)
    .eq('id', id)
    .select()

  if (error) throw error
  return data[0]
}

// DELETE - Delete user
export async function deleteUser(id: string) {
  const { error } = await supabase
    .from('users')
    .delete()
    .eq('id', id)

  if (error) throw error
}`;
      } else if (taskLower.includes('storage') || taskLower.includes('file')) {
        return `import { createClient } from '@supabase/supabase-js'

const supabase = createClient(
  process.env.EXPO_PUBLIC_SUPABASE_URL!,
  process.env.EXPO_PUBLIC_SUPABASE_ANON_KEY!
)

// Upload file to storage
export async function uploadFile(bucket: string, filePath: string, file: File) {
  const { data, error } = await supabase.storage
    .from(bucket)
    .upload(filePath, file)

  if (error) throw error
  return data
}

// Download file from storage
export async function downloadFile(bucket: string, filePath: string) {
  const { data, error } = await supabase.storage
    .from(bucket)
    .download(filePath)

  if (error) throw error
  return data
}

// Get public URL for file
export function getPublicUrl(bucket: string, filePath: string) {
  const { data } = supabase.storage
    .from(bucket)
    .getPublicUrl(filePath)

  return data.publicUrl
}

// List files in bucket
export async function listFiles(bucket: string, folderPath = '') {
  const { data, error } = await supabase.storage
    .from(bucket)
    .list(folderPath)

  if (error) throw error
  return data
}

// Delete file
export async function deleteFile(bucket: string, filePath: string) {
  const { error } = await supabase.storage
    .from(bucket)
    .remove([filePath])

  if (error) throw error
}`;
      } else if (taskLower.includes('realtime') || taskLower.includes('subscription')) {
        return `import { createClient } from '@supabase/supabase-js'

const supabase = createClient(
  process.env.EXPO_PUBLIC_SUPABASE_URL!,
  process.env.EXPO_PUBLIC_SUPABASE_ANON_KEY!
)

// Real-time subscription to table changes
export function subscribeToUsers(callback: (payload: any) => void) {
  const channel = supabase
    .channel('users-changes')
    .on(
      'postgres_changes',
      {
        event: '*',
        schema: 'public',
        table: 'users'
      },
      (payload) => {
        callback(payload)
      }
    )
    .subscribe()

  return channel
}

// Subscribe to specific user updates
export function subscribeToUser(userId: string, callback: (payload: any) => void) {
  const channel = supabase
    .channel(\`user-\${userId}\`)
    .on(
      'postgres_changes',
      {
        event: '*',
        schema: 'public',
        table: 'users',
        filter: \`id=eq.\${userId}\`
      },
      (payload) => {
        callback(payload)
      }
    )
    .subscribe()

  return channel
}

// Broadcast custom events
export async function broadcastEvent(eventName: string, data: any) {
  const channel = supabase.channel('custom-events')

  await channel.subscribe(async (status) => {
    if (status === 'SUBSCRIBED') {
      await channel.send({
        type: 'broadcast',
        event: eventName,
        payload: data
      })
    }
  })

  return channel
}

// Listen for custom events
export function listenForEvents(eventName: string, callback: (payload: any) => void) {
  const channel = supabase.channel('custom-events')

  channel
    .on('broadcast', { event: eventName }, ({ payload }) => {
      callback(payload)
    })
    .subscribe()

  return channel
}`;
      } else if (taskLower.includes('react native') || taskLower.includes('expo')) {
        return `// React Native Supabase Setup
import { createClient } from '@supabase/supabase-js'
import AsyncStorage from '@react-native-async-storage/async-storage'

const supabaseUrl = process.env.EXPO_PUBLIC_SUPABASE_URL!
const supabaseAnonKey = process.env.EXPO_PUBLIC_SUPABASE_ANON_KEY!

// Create Supabase client with AsyncStorage for persistence
export const supabase = createClient(supabaseUrl, supabaseAnonKey, {
  auth: {
    storage: AsyncStorage,
    autoRefreshToken: true,
    persistSession: true,
    detectSessionInUrl: false
  }
})

// React Hook for authentication
import { useState, useEffect } from 'react'

export function useAuth() {
  const [user, setUser] = useState(null)
  const [loading, setLoading] = useState(true)

  useEffect(() => {
    // Get initial session
    supabase.auth.getSession().then(({ data: { session } }) => {
      setUser(session?.user ?? null)
      setLoading(false)
    })

    // Listen for auth changes
    const { data: { subscription } } = supabase.auth.onAuthStateChange(
      async (event, session) => {
        setUser(session?.user ?? null)
        setLoading(false)
      }
    )

    return () => subscription.unsubscribe()
  }, [])

  return { user, loading }
}

// Example usage in component:
/*
import { useAuth } from './supabase'

export default function ProfileScreen() {
  const { user, loading } = useAuth()

  if (loading) return <Text>Loading...</Text>
  if (!user) return <Text>Not logged in</Text>

  return <Text>Welcome {user.email}!</Text>
}
*/`;
    } else {
        return `// Supabase Client Setup
import { createClient } from '@supabase/supabase-js'

const supabaseUrl = process.env.EXPO_PUBLIC_SUPABASE_URL!
const supabaseAnonKey = process.env.EXPO_PUBLIC_SUPABASE_ANON_KEY!

// Create Supabase client
export const supabase = createClient(supabaseUrl, supabaseAnonKey)

// Example usage:
// 1. Authentication
// const { data, error } = await supabase.auth.signUp({ email, password })

// 2. Database operations
// const { data, error } = await supabase.from('users').select('*')

// 3. Storage
// const { data, error } = await supabase.storage.from('bucket').upload('path', file)

// 4. Real-time subscriptions
// const channel = supabase.channel('changes').on('postgres_changes', {...}).subscribe()`;
      }

    // Default fallback
    return `// Hello World in ${language}
console.log("Hello, World! Welcome to ${language}!");`;

    // This should never be reached, but ensures all code paths return
    return `// Default code example`;
  }
}

// Export singleton instance
export const aiService = new AIService();
